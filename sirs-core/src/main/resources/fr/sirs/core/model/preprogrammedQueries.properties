#
# Ce fichier contient les requetes pr\u00e9programm\u00e9es.
#=================================================
#
# Chaque requ\u00eate est d\u00e9crite par trois proprit\u00e9s.
# 1- la propri\u00e9t\u00e9 suffix\u00e9e par ".title" indique le libell\u00e9 de la requ\u00eate
# 2- la propri\u00e9t\u00e9 suffix\u00e9e par ".description" indique la description de la requ\u00eate
# 3- la propri\u00e9t\u00e9 suffix\u00e9e par ".query" indique le corps de la requ\u00eate en SQL
#
# \u00c0 noter que :
# - l'ordre des propri\u00e9t\u00e9s importe peu
# - le nom des propri\u00e9t\u00e9 priv\u00e9 du suffixe ".title", ".description" ou ".query" sert 
# d'identifiant \u00e0 la requ\u00eate pr\u00e9programm\u00e9e ; un m\u00eame identifiant ne doit pas \u00eatre 
# utilis\u00e9 pour deux requ\u00eates distinctes
#
# Pour am\u00e9liorer la lisibilit\u00e9 des informations, on recommande d'utiliser les passages 
# \u00e0 la ligne. Ceux-ci sont de deux sortes :
# - les passages \u00e0 la ligne lors de l'affichage sont indiqu\u00e9s par le caract\u00e8re '\n'
# - les passages \u00e0 la ligne dans le pr\u00e9sent fichier pour une valeur de proprit\u00e9t\u00e9 sont indiqu\u00e9e par le caract\u00e8re '\'
#
# @author Samuel Andr\u00e9s (Geomatys)
#
#
newPonctualDisordersByType.title=Nouveaux d\u00e9sordres ponctuels par type
newPonctualDisordersByType.description=On consid\u00e8re la "nouveaut\u00e9" en classant les d\u00e9sordres par date de d\u00e9but d\u00e9croissante. \n\
On consid\u00e8re la "ponctualit\u00e9" par l'identit\u00e9 des positions de d\u00e9but et de fin \n\
ou bien par l'identit\u00e9 des PRs de d\u00e9but et de fin, ou bien par la nullit\u00e9 \n\
de la position de fin si la position de d\u00e9but n'est pas nulle.
newPonctualDisordersByType.query=select d."id", d."designation", d."date_debut", d."date_fin", d."prDebut", d."prFin", t."libelle" as "type" \n\
from "Desordre" d, "RefTypeDesordre" t \n\
where d."typeDesordreId" like t."id" \n\
    and (d."positionDebut" like d."positionFin" or d."prDebut" like d."prFin" or (d."positionDebut" is not null and d."positionFin" is null)) \n\
    and (d."date_fin" is null) \n\
order by d."date_debut" desc, t."libelle" asc
#
newLinearDisordersByType.title=Nouveaux d\u00e9sordres lin\u00e9aires par type
newLinearDisordersByType.description=On consid\u00e8re la "nouveaut\u00e9" en classant les d\u00e9sordres par date de d\u00e9but d\u00e9croissante \n\
On consid\u00e8re la "lin\u00e9arit\u00e9" par la diff\u00e9rence des positions de d\u00e9but et de fin \n\
ou bien par la diff\u00e9rence des PRs de d\u00e9but et de fin.
newLinearDisordersByType.query=select d."id", d."designation", d."date_debut", d."date_fin", d."prDebut", d."prFin", t."libelle" as "type" \n\
from "Desordre" d, "RefTypeDesordre" t \n\
where d."typeDesordreId" like t."id" \n\
    and (d."positionDebut" not like d."positionFin" or d."prDebut" not like d."prFin") \n\
    and (d."date_fin" is null) \n\
order by d."date_debut" desc, t."libelle" asc
#
processedDisordersByType.title=D\u00e9sordres trait\u00e9s sur une p\u00e9riode par type
processedDisordersByType.query=select d."id", d."designation", d."date_debut", d."date_fin", d."prDebut", d."prFin", t."libelle" as "type" \n\
from "Desordre" d, "RefTypeDesordre" t \n\
where d."typeDesordreId" like t."id" and d."date_fin">'2011-01-01' and d."date_fin"<'2012-01-01'
processedDisordersByType.description=La p\u00e9riode de la requ\u00eate est l'ann\u00e9e 2011.
#
observerdDisordersBySection.title=D\u00e9sordres observ\u00e9s par tron\u00e7on
observerdDisordersBySection.query=select d."id", d."designation", td."libelle" \n\
from "Desordre" d, "TronconDigue" td \n\
where d."linearId" like td."id" \n\
order by td."id"
observerdDisordersBySection.description=
#
countDisordersByBank.title=D\u00e9nombrement des d\u00e9sordres par rive
countDisordersByBank.query=select count(*), r."libelle" \n\
from "Desordre" d, "TronconDigue" t, "RefRive" r \n\
where d."linearId" like t."id" and t."typeRiveId" like r."id" \n\
group by r."id" \n\
order by r."libelle"
countDisordersByBank.description=
#
disordersByBank.title=D\u00e9sordres par rive
disordersByBank.query=select d."id", d."designation", r."libelle" \n\
from "Desordre" d, "TronconDigue" t, "RefRive" r \n\
where d."linearId" like t."id" and t."typeRiveId" like r."id" \n\
order by r."libelle"
disordersByBank.description=
#
costOfMaintenanceWorkByType.title=Montant des travaux d'entretien par type de travail
costOfMaintenanceWorkByType.query=select sum("coutGlobal") as cout, tp."libelle" \n\
from "Prestation" p, "RefPrestation" tp \n\
where p."typePrestationId" like tp."id" \n\
group by "typePrestationId" \n\
order by cout desc
costOfMaintenanceWorkByType.description=
#
costOfMaintenanceWorkByTypeBySection.title=Montant des travaux d'entretien par type de travail par tron\u00e7on
costOfMaintenanceWorkByTypeBySection.query=select sum("coutGlobal") as cout, tp."libelle" as prestation, td."libelle" as troncon  from "Prestation" p, "RefPrestation" tp, "TronconDigue" td  where p."typePrestationId" like tp."id" and td."id" like p."linearId" group by "typePrestationId", td."id" order by cout desc
costOfMaintenanceWorkByTypeBySection.description=
#
objectLengthByType.title=Longueur cumul\u00e9e des objets de structure par type
objectLengthByType.query=select "concrete_table_name", sum(abs("prFin"-"prDebut")) as "lin\u00e9aire (km)" from "ObjetStructure" group by "concrete_table_name"
objectLengthByType.description=
#
objectLengthBySectionByType.title=Longueur cumul\u00e9e des objets de structure par type et par tron\u00e7on
objectLengthBySectionByType.query=select s."concrete_table_name" as "type d'\u00e9l\u00e9ment", t."libelle", t."designation", sum(abs(s."prFin"-s."prDebut")) as "lin\u00e9aire (km)" from "ObjetStructure" s, "TronconDigue" t where t."id"=s."linearId" group by s."concrete_table_name", s."linearId" order by "concrete_table_name", s."linearId"
objectLengthBySectionByType.description=
#
rhfAndProperty.title=Conduites ferm\u00e9es avec informations de propri\u00e9t\u00e9
rhfAndProperty.query=select RHF.*, TD."libelle" as tid, PO."date_debut" as "Debut de propri\u00e9t\u00e9", PO."date_fin" as "Fin de propri\u00e9t\u00e9", ORG."nom" as "Organisme", ORG."telephone" as "T\u00e9l\u00e9phone organisme", ORG."email" as "E-mail organisme", CON."nom" as "Contact", CON."telephone" as "T\u00e9l\u00e9phone particulier", CON."email" as "E-mail particulier" FROM ("ReseauHydrauliqueFerme" RHF left join "ProprieteObjet" PO ON RHF."id" \= PO."parent_id" left join "TronconDigue" TD ON TD."id" \= RHF."linearId" left join "Organisme" ORG ON ORG."id" \= PO."organismeId" left join "Contact" CON on CON."id" \= PO."contactId")
rhfAndProperty.description=S\u00e9lection des conduites ferm\u00e9es avec les noms et coordonn\u00e9es des propri\u00e9taires (organismes ou personnes physiques) et le nom du tron\u00e7on
#
currentDisordersAndLastObservation.title=Desordres courants avec derni\u00e8re observation
currentDisordersAndLastObservation.query=SELECT \n-- infos sur le desordre\nd."id", d."designation", \nd."date_debut", \nd."prDebut",\nd."prFin",\ncat."abrege" as code_cat,\ncat."libelle" as nom_cat,\ntype_d."abrege" code_type,\ntype_d."libelle" as nom_type, \n-- infos sur le tron\u00e7on\ntr."designation" as code_tron\u00e7on,\ntr."libelle" as nom_tron\u00e7on,\n-- infos sur la derni\u00e8re observation\no."designation" as code_observation,\no."date" as date_observation,\nu."abrege" as code_urgence,\nu."libelle" as titre_urgence\nFROM\n(SELECT "id", "designation", "date_debut", "prDebut", "prFin", "categorieDesordreId", "typeDesordreId", "linearId" FROM "Desordre" WHERE "date_fin" IS NULL) d \n    -- infos sur les cat\u00e9gories des d\u00e9sordres\n    LEFT JOIN "RefCategorieDesordre" cat ON cat."id" \= d."categorieDesordreId" \n    -- infos sur le type des d\u00e9sordres\n    LEFT JOIN "RefTypeDesordre" type_d ON type_d."id" \= d."typeDesordreId"\n    -- Tron\u00e7ons affect\u00e9s\n    LEFT JOIN "TronconDigue" tr ON tr."id" \= d."linearId"\n    LEFT JOIN \n        -- On r\u00e9cup\u00e8re les observations pour chaque d\u00e9sordre choisi.\n        (SELECT "designation", "date", "parent_id", "urgenceId" FROM "Observation"  \n            INNER JOIN\n                -- Observations \u00e0 la date la plus r\u00e9cente pour chaque d\u00e9sordre\n                (SELECT "parent_id" as tmp_pid, MAX("date") as max_date from "Observation" GROUP BY "parent_id") o0 \n            ON "parent_id" \= o0.tmp_pid and "date" \= o0.max_date\n        ) o ON o."parent_id" \= d."id"\n    -- urgence of the returned observations\n    LEFT JOIN "RefUrgence" u ON u."id" \= o."urgenceId"\n    -- tri par date d'observation\n    ORDER BY date_observation DESC;
currentDisordersAndLastObservation.description=Tous les d\u00e9sordres non trait\u00e9s. Informations compl\u00e9mentaires \: \nTron\u00e7on associ\u00e9 et PR sur le tron\u00e7on,\nType du d\u00e9sordre,\nObservations \u00e0 la date la plus r\u00e9cente, avec degr\u00e9 d'urgence.\n\nTri\u00e9 par date d'observation (de la plus r\u00e9cente \u00e0 la plus ancienne).
#
chargeAndHeightForFlood.title=Charge et hauteur de revanche hydraulique pour chaque crue
chargeAndHeightForFlood.description=Sur chaque tron\u00e7on, on retrouve les profils en travers associ\u00e9s \u00e0 un \u00e9venement hydraulique. \n\
On fait la moyenne des cotes de lev\u00e9 pour chaque profil, et on calcule la charge \n\
et la hauteur de revanche pour chaque \u00e9venement hydraulique li\u00e9.
chargeAndHeightForFlood.query=SELECT \n\
tr."id", tr."designation" as CODE_TRONCON, \n\
tr."libelle" as NOM_TRONCON, \n\
"prDebut" as PR_DEBUT, \n\
"prFin" as PR_FIN, \n\
NOM_PROFIL, \n\
eh."designation" as CODE_CRUE, \n\
eh."libelle" as NOM_CRUE, \n\
COTE_CRETE, \n\
COTE_PIED_TERRE, \n\
COTE_EAU, \n\
COTE_CRETE - COTE_PIED_TERRE as hauteur_digue_terre, \n\
COTE_EAU - COTE_PIED_TERRE as charge, \n\
COTE_CRETE - COTE_EAU as revanche \n\
FROM \n\
    -- Tous les param\u00e8tres hydrauliques (avec les infos sur le profil en travers cible) associ\u00e9s \u00e0 une crue \n\
    (select pt."id" as ptid, pt."libelle" as NOM_PROFIL, ph."coteEau" as COTE_EAU, ph."evenementHydrauliqueId" as crue_id \n\
    from "ProfilTravers" pt \n\
    inner join "ParametreHydrauliqueProfilTravers" ph on ph."parent_id" = pt."id" and ph."evenementHydrauliqueId" is not null and ph."coteEau" > 0) \n\
INNER JOIN "EvenementHydraulique" eh ON eh."id" = crue_id \n\
-- On prend les moyennes associ\u00e9es \n\
INNER JOIN \n\
    (\n\
        -- La moyenne des lev\u00e9s pour chaque position de profil \n\
        select posId, "linearId", "prDebut", "prFin", "sirsdocument", AVG(lppt."cotePiedDigueTerre") as COTE_PIED_TERRE, AVG(lppt."coteCrete") as COTE_CRETE \n\
        from "LevePositionProfilTravers" lppt \n\
        inner join \n\
            (select * from "LevePositionProfilTraversPositionProfilTravers" \n\
                inner join (select "id" as posId, "linearId", "prDebut", "prFin", "sirsdocument" from "PositionProfilTravers") on "positionProfilTraversId" = posId) lpptppt \n\
            ON lppt."id" = lpptppt."levePositionProfilTraversId"\n\
        GROUP BY posId, "linearId", "prDebut", "prFin", "sirsdocument"\n\
    ) ml ON ml."sirsdocument" = ptid\n\
-- On trouve les infos sur les tron\u00e7ons concern\u00e9s\n\
INNER JOIN "TronconDigue" tr ON tr."id" = ml."linearId"\n\
-- Tri\u00e9 par tron\u00e7on, puis de l'amont vers l'aval.\n\
ORDER BY tr."id", PR_DEBUT;
#
disorders.title= Tableau de d\u00e9sordres
disorders.description=R\u00e9capitulatif des d\u00e9sordres avec leur tron\u00e7on et la classe du syst\u00e8me d'endiguement, \n\
leur position, l'abr\u00e9g\u00e9 de la derni\u00e8re urgence et leur type. \n\
Pour s\u00e9lectionner un ou plusieurs tron\u00e7ons particuliers, un type de d\u00e9sordre, une classe de digue ou une date de fin, \n\
modifier les valeurs indiqu\u00e9es dans la clause WHERE en cons\u00e9quence.
disorders.query=SELECT \n\
-- infos sur le desordre \n\
tr."designation" as numero_troncon, \n\
d."designation",  \n\
bd."libelle" as borne_debut, \n\
d."borne_debut_aval", \n\
d."borne_debut_distance", \n\
st_asText(d."positionDebut") as position_debut, \n\
bf."libelle" as borne_fin, \n\
d."borne_fin_aval", \n\
d."borne_fin_distance", \n\
st_asText(d."positionFin") as position_fin, \n\
u."abrege" as code_urgence, \n\
cot."libelle" as cot\u00e9, \n\
pos."libelle" as position, \n\
type_d."libelle" as type, \n\
se."classement" as classe_digue \n\
FROM \n\
    "Desordre" d  \n\
    -- infos sur le type des d\u00e9sordres \n\
    LEFT JOIN "RefTypeDesordre" type_d ON type_d."id" = d."typeDesordreId" \n\
    -- Tron\u00e7ons affect\u00e9s \n\
    LEFT JOIN "TronconDigue" tr ON tr."id" = d."linearId" \n\
    LEFT JOIN "Digue" dig ON dig."id" = tr."digueId" \n\
    LEFT JOIN "SystemeEndiguement" se ON se."id" = dig."systemeEndiguementId" \n\
    LEFT JOIN "BorneDigue" bd ON bd."id" = d."borneDebutId" \n\
    LEFT JOIN "BorneDigue" bf ON bf."id" = d."borneFinId" \n\
    LEFT JOIN "RefCote" cot ON cot."id" = d."coteId" \n\
    LEFT JOIN "RefPosition" pos ON pos."id" = d."positionId" \n\
    LEFT JOIN  \n\
        -- On r\u00e9cup\u00e8re les observations pour chaque d\u00e9sordre choisi. \n\
        (SELECT "parent_id", "urgenceId" FROM "Observation" \n\
            INNER JOIN \n\
                -- Observations \u00e0 la date la plus r\u00e9cente pour chaque d\u00e9sordre \n\
                (SELECT "parent_id" as tmp_pid, MAX("date") as max_date from "Observation" GROUP BY "parent_id") o0 \n\
            ON "parent_id" = o0.tmp_pid and "date" = o0.max_date \n\
        ) o ON o."parent_id" = d."id" \n\
    -- urgence of the returned observations \n\
    LEFT JOIN "RefUrgence" u ON u."id" = o."urgenceId" \n\
    WHERE (tr."designation" IS NOT NULL OR tr."designation" IS NULL) \n\
    AND (type_d."designation" IS NOT NULL OR type_d."designation" IS NULL) \n\
    AND (se."classement" IS NOT NULL OR se."classement" IS NULL) \n\
    AND d."date_fin" IS NULL;
#
closed.hydrolic.networks.title=R\u00e9seaux hydrauliques ferm\u00e9s
closed.hydrolic.networks.description=R\u00e9capitulatif des r\u00e9seaux hydrauliques ferm\u00e9s avec leur tron\u00e7on et la classe du syst\u00e8me d'endiguement, \n\
leur position, l'abr\u00e9g\u00e9 de la derni\u00e8re urgence et leur type. \n\
Pour s\u00e9lectionner un ou plusieurs tron\u00e7ons particuliers, une classe de digue ou une date de fin, \n\
modifier les valeurs indiqu\u00e9es dans la clause WHERE en cons\u00e9quence.
closed.hydrolic.networks.query=SELECT \n\
-- infos sur le r\u00e9seau hydraulique ferm\u00e9 \n\
tr."designation" as numero_troncon, \n\
rhf."designation", \n\
bd."libelle" as borne_debut, \n\
rhf."borne_debut_aval", \n\
rhf."borne_debut_distance", \n\
rhf.st_asText("positionDebut") as position_debut, \n\
bf."libelle" as borne_fin, \n\
rhf."borne_fin_aval", \n\
rhf."borne_fin_distance", \n\
rhf.st_asText("positionFin") as position_fin, \n\
rhf."libelle", \n\
cot."libelle" as cot\u00e9, \n\
pos."libelle" as position, \n\
rhf."diametre", \n\
se."classement" as classe_digue, \n\
o."evolution", \n\
o."suite" \n\
FROM \n\
    "ReseauHydrauliqueFerme" rhf \n\
    -- Tron\u00e7ons affect\u00e9s \n\
    LEFT JOIN "TronconDigue" tr ON tr."id" = rhf."linearId" \n\
    LEFT JOIN "Digue" dig ON dig."id" = tr."digueId" \n\
    LEFT JOIN "SystemeEndiguement" se ON se."id" = dig."systemeEndiguementId" \n\
    LEFT JOIN "BorneDigue" bd ON bd."id" = rhf."borneDebutId" \n\
    LEFT JOIN "BorneDigue" bf ON bf."id" = rhf."borneFinId" \n\
    LEFT JOIN "RefCote" cot ON cot."id" = rhf."coteId" \n\
    LEFT JOIN "RefPosition" pos ON pos."id" = rhf."positionId" \n\
    LEFT JOIN  \n\
        -- On r\u00e9cup\u00e8re les observations pour chaque rhf choisi. \n\
        (SELECT "parent_id", "evolution", "suite" FROM "ObservationReseauHydrauliqueFerme" \n\
            INNER JOIN \n\
                -- Observations \u00e0 la date la plus r\u00e9cente pour chaque rhf \n\
                (SELECT "parent_id" as tmp_pid, MAX("date") as max_date from "ObservationReseauHydrauliqueFerme" GROUP BY "parent_id") o0 \n\
            ON "parent_id" = o0.tmp_pid and "date" = o0.max_date \n\
        ) o ON o."parent_id" = rhf."id" \n\
    WHERE (tr."designation" IS NOT NULL OR tr."designation" IS NULL) \n\
    AND (se."classement" IS NOT NULL or se."classement" is null) \n\
    AND rhf."date_fin" IS NULL;
#
newDisorders.title= Tableau des nouveaux d\u00e9sordres
newDisorders.description=R\u00e9capitulatif des nouveaux d\u00e9sordres avec leur tron\u00e7on et la classe du syst\u00e8me d'endiguement, \n\
leur position, leur type et l'abr\u00e9g\u00e9 de l'urgence et la date de la derni\u00e8re observation. \n\
Pour s\u00e9lectionner un ou plusieurs tron\u00e7ons particuliers, un type de d\u00e9sordre, une classe de digue, \n\
une p\u00e9riode temporelle sur la date de la derni\u00e8re observation ou une date de fin, \n\
modifier les valeurs indiqu\u00e9es dans la clause WHERE en cons\u00e9quence.
newDisorders.query=SELECT \n\
-- infos sur le desordre \n\
tr."designation" as numero_troncon, \n\
d."designation", \n\
o."date" as date_observation, \n\
u."abrege" as code_urgence, \n\
type_d."libelle" as type, \n\
cot."libelle" as cot\u00e9, \n\
pos."libelle" as position, \n\
bd."libelle" as borne_debut, \n\
d."borne_debut_aval", \n\
d."borne_debut_distance", \n\
st_asText(d."positionDebut") as position_debut, \n\
bf."libelle" as borne_fin, \n\
d."borne_fin_aval", \n\
d."borne_fin_distance", \n\
st_asText(d."positionFin") as position_fin, \n\
se."classement" as classe_digue \n\
FROM \n\
    "Desordre" d \n\
    -- infos sur le type des d\u00e9sordres \n\
    LEFT JOIN "RefTypeDesordre" type_d ON type_d."id" = d."typeDesordreId" \n\
    -- Tron\u00e7ons affect\u00e9s \n\
    LEFT JOIN "TronconDigue" tr ON tr."id" = d."linearId" \n\
    LEFT JOIN "Digue" dig ON dig."id" = tr."digueId" \n\
    LEFT JOIN "SystemeEndiguement" se ON se."id" = dig."systemeEndiguementId" \n\
    LEFT JOIN "BorneDigue" bd ON bd."id" = d."borneDebutId" \n\
    LEFT JOIN "BorneDigue" bf ON bf."id" = d."borneFinId" \n\
    LEFT JOIN "RefCote" cot ON cot."id" = d."coteId" \n\
    LEFT JOIN "RefPosition" pos ON pos."id" = d."positionId" \n\
    LEFT JOIN  \n\
        -- On r\u00e9cup\u00e8re les observations pour chaque d\u00e9sordre choisi. \n\
        (SELECT "parent_id", "urgenceId", "date" FROM "Observation" \n\
            INNER JOIN \n\
                -- Observations \u00e0 la date la plus r\u00e9cente pour chaque d\u00e9sordre \n\
                (SELECT "parent_id" as tmp_pid, MAX("date") as max_date from "Observation" GROUP BY "parent_id") o0 \n\
            ON "parent_id" = o0.tmp_pid and "date" = o0.max_date \n\
        ) o ON o."parent_id" = d."id" \n\
    -- urgence of the returned observations \n\
    LEFT JOIN "RefUrgence" u ON u."id" = o."urgenceId" \n\
    WHERE (tr."designation" IS NOT NULL OR tr."designation" IS NULL) \n\
    AND (type_d."designation" IS NOT NULL OR type_d."designation" IS NULL) \n\
    AND (o."date" IS NOT NULL OR o."date" IS NULL) \n\
    AND (se."classement" IS NOT NULL OR se."classement" IS NULL) \n\
    AND d."date_fin" IS NULL;