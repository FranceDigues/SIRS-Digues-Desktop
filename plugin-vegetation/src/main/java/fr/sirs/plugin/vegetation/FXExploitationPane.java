
package fr.sirs.plugin.vegetation;

import fr.sirs.Injector;
import fr.sirs.SIRS;
import fr.sirs.Session;
import fr.sirs.core.model.PlanVegetation;
import fr.sirs.core.model.TronconDigue;
import static fr.sirs.plugin.vegetation.FXPlanTable.CHECKBOX_NO_LABEL_PADDING;
import static fr.sirs.plugin.vegetation.FXPlanTable.Mode.EXPLOITATION;
import static fr.sirs.plugin.vegetation.VegetationSession.NON_PLANIFIE_NON_TRAITE;
import static fr.sirs.plugin.vegetation.VegetationSession.NON_PLANIFIE_TRAITE;
import static fr.sirs.plugin.vegetation.VegetationSession.PLANIFIE_NON_TRAITE;
import static fr.sirs.plugin.vegetation.VegetationSession.PLANIFIE_TRAITE;
import fr.sirs.util.SirsStringConverter;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.embed.swing.SwingFXUtils;
import javafx.fxml.FXML;
import javafx.geometry.HPos;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.Tab;
import javafx.scene.image.ImageView;
import javafx.scene.layout.Background;
import javafx.scene.layout.Border;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.util.StringConverter;
import org.geotoolkit.font.FontAwesomeIcons;
import org.geotoolkit.font.IconBuilder;

/**
 *
 * @author Johann Sorel (Geomatys)
 */
public class FXExploitationPane extends BorderPane {

    @FXML private Tab tabPlanificationExploitation;
    @FXML private Tab tabTraitements;
    @FXML private Tab tabImpression;
    @FXML private BorderPane uiPlanTable;
    @FXML private GridPane uiHeader;

    final ComboBox<Integer> uiAnneeChoice = new ComboBox<>();
    final CheckBox filterPlanifieNonTraite = new CheckBox(PLANIFIE_NON_TRAITE);
    final CheckBox filterNonPlanifieTraite = new CheckBox(NON_PLANIFIE_TRAITE);
    final CheckBox filterPlanifieTraite = new CheckBox(PLANIFIE_TRAITE);

    public FXExploitationPane() {
        SIRS.loadFXML(this, FXParametragePane.class);
        setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
    }

    public void initialize() {
//        tablePane.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
        final Session session = Injector.getSession();

        //plan de gestion actif
        final ChoiceBox<PlanVegetation> planChoiceBox = new ChoiceBox<>();
        planChoiceBox.setMaxWidth(300);
        planChoiceBox.setConverter(new SirsStringConverter());
        final List<PlanVegetation> allPlan = session.getRepositoryForClass(PlanVegetation.class).getAll();
        planChoiceBox.setItems(FXCollections.observableArrayList(allPlan));
        planChoiceBox.valueProperty().bindBidirectional(VegetationSession.INSTANCE.planProperty());
        final Label lblPlan = new Label("Plan de gestion actif : ");
        lblPlan.getStyleClass().add("label-header");
        lblPlan.setMinWidth(30);

        //troncon actif
        final ChoiceBox<TronconDigue> tronconChoiceBox = new ChoiceBox<>();
        tronconChoiceBox.setMaxWidth(300);
        tronconChoiceBox.setConverter(new SirsStringConverter());
        final List<TronconDigue> allTroncon = session.getRepositoryForClass(TronconDigue.class).getAll();
        allTroncon.add(0, null);
        tronconChoiceBox.setItems(FXCollections.observableArrayList(allTroncon));
        final Label lblTroncon = new Label("Tronçon : ");
        lblTroncon.getStyleClass().add("label-header");
        lblTroncon.setMinWidth(30);


        uiHeader.setMaxSize(Double.MAX_VALUE, Double.MAX_VALUE);
        uiHeader.setHgap(10);
        uiHeader.setVgap(10);
        uiHeader.setPadding(new Insets(10, 10, 10, 10));
        uiHeader.add(lblPlan, 1, 0);
        uiHeader.add(planChoiceBox, 2, 0);
        uiHeader.add(lblTroncon, 3, 0);
        uiHeader.add(tronconChoiceBox, 4, 0);
        final Label lblTitle = new Label("Exploitation des parcelles");
        lblTitle.setPadding(new Insets(0, 40, 0, 40));
        lblTitle.getStyleClass().add("label-header");
        lblTitle.setStyle("-fx-font-size: 1.5em;");
        uiHeader.add(lblTitle, 0, 0);

        filterPlanifieNonTraite.setSelected(true);
        filterNonPlanifieTraite.setSelected(true);
        filterPlanifieTraite.setSelected(true);

        filterPlanifieNonTraite.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());
        filterNonPlanifieTraite.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());
        filterPlanifieTraite.disableProperty().bind(uiAnneeChoice.getSelectionModel().selectedItemProperty().isNull());

        final HBox filter = new HBox(uiAnneeChoice, filterPlanifieNonTraite, filterNonPlanifieTraite, filterPlanifieTraite);
        filter.setSpacing(30);
        uiHeader.add(filter, 1, 1, 4, 1);

        final Button lblInfo = new Button(null, new ImageView(SwingFXUtils.toFXImage(IconBuilder.createImage(FontAwesomeIcons.ICON_INFO_CIRCLE, 32, Color.WHITE),null)));
        lblInfo.setBackground(Background.EMPTY);
        lblInfo.setBorder(Border.EMPTY);
        lblInfo.setPadding(Insets.EMPTY);
        lblInfo.setOnMouseClicked(e -> {
            final Stage infoStage = new Stage(StageStyle.UNDECORATED);

            final GridPane grid = new GridPane();
            grid.setPadding(new Insets(10, 10, 10, 10));
            grid.setHgap(10);
            grid.setVgap(10);

            final Label lgdTitle = new Label("Légende :");
            lgdTitle.setStyle("-fx-font-weight: bold; -fx-underline: true;");
            grid.add(lgdTitle, 0, 0, 2, 1);

            final CheckBox npf = new CheckBox();
            npf.setDisable(true);
            npf.setSelected(true);
            npf.setPadding(new Insets(10));
            npf.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(npf, null);
            grid.add(npf, 0, 1);
            grid.add(new Label("Parcelle planifiée (l'année courante ou dans l'avenir) et non traitée."), 1, 1);

            final CheckBox pt = new CheckBox();
            pt.setDisable(true);
            pt.setSelected(true);
            pt.setPadding(new Insets(10));
            pt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(pt, PLANIFIE_TRAITE);
            grid.add(pt, 0, 2);
            grid.add(new Label("Parcelle planifiée et traitée."), 1, 2);

            final CheckBox pnt = new CheckBox();
            pnt.setDisable(true);
            pnt.setSelected(true);
            pnt.setPadding(new Insets(10));
            pnt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(pnt, PLANIFIE_NON_TRAITE);
            grid.add(pnt, 0, 3);
            grid.add(new Label("Parcelle planifiée (dans le passé) et non traitée."), 1, 3);

            final CheckBox npt = new CheckBox();
            npt.setDisable(true);
            npt.setSelected(false);
            npt.setPadding(new Insets(10));
            npt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(npt, NON_PLANIFIE_TRAITE);
            grid.add(npt, 0, 4);
            grid.add(new Label("Parcelle non planifiée mais traitée."), 1, 4);

            final CheckBox npnt = new CheckBox();
            npnt.setDisable(true);
            npnt.setSelected(false);
            npnt.setPadding(new Insets(10));
            npnt.setStyle(CHECKBOX_NO_LABEL_PADDING);
            VegetationSession.setCheckBoxColor(npnt, NON_PLANIFIE_NON_TRAITE);
            grid.add(npnt, 0, 5);
            grid.add(new Label("Parcelle ni planifiée ni traitée."), 1, 5);

            final Button ok = new Button("Fermer");
            ok.setOnAction(ev -> infoStage.hide());
            grid.add(ok, 0, 6, 2, 1);
            GridPane.setHalignment(ok, HPos.CENTER);

            final Scene scene = new Scene(grid);

            infoStage.setScene(scene);
            infoStage.initModality(Modality.APPLICATION_MODAL);
            infoStage.showAndWait();
        });

        lblTitle.setPadding(new Insets(0, 10, 0, 40));
        uiHeader.add(lblInfo, 5, 0);
        uiHeader.getStyleClass().add("blue-light");
        
        tabTraitements.setContent(new FXTraitementsPane());

        if(planChoiceBox.getValue()!=null){
            uiPlanTable.setCenter(new FXPlanTable(planChoiceBox.getValue(), tronconChoiceBox.getValue(), EXPLOITATION, buildsFilter(), uiAnneeChoice.getValue()==null?0:uiAnneeChoice.getValue()));
        }

        //on ecoute les changements de troncon et de plan
        final ChangeListener chgListener = new ChangeListener() {
            @Override
            public void changed(ObservableValue observable, Object oldValue, Object newValue) {
                uiPlanTable.setCenter(new FXPlanTable(planChoiceBox.getValue(), tronconChoiceBox.getValue(), EXPLOITATION, buildsFilter(), uiAnneeChoice.getValue()==null?0:uiAnneeChoice.getValue()));
                
                /*
                Si c'est le plan qui a changé, il faut recharger les années.
                */
                if(newValue instanceof PlanVegetation){
                    final List<Integer> annees = new ArrayList<>();
                    final PlanVegetation plan = (PlanVegetation) newValue;
                    final int nbAnnees = plan.getAnneeFin() - plan.getAnneeDebut();
                    for(int i=0; i<nbAnnees; i++){
                        annees.add(i);
                    }
                    uiAnneeChoice.setItems(FXCollections.observableList(annees));
                    uiAnneeChoice.setConverter(new StringConverter<Integer>() {

                        @Override
                        public String toString(Integer object) {
                            return String.valueOf(object + plan.getAnneeDebut());
                        }

                        @Override
                        public Integer fromString(String string) {
                            return Integer.getInteger(string)-plan.getAnneeDebut();
                        }
                    });
                }
            }
        };
        
        planChoiceBox.valueProperty().addListener(chgListener);
        tronconChoiceBox.valueProperty().addListener(chgListener);

        tabImpression.setContent(new BorderPane(new FXImpression()));
    }


    private List<String> buildsFilter(){
        if(uiAnneeChoice.getValue()==null) return null;
        else{
            final List<String> result = new ArrayList<>();
            if(!filterPlanifieNonTraite.isSelected()) result.add(PLANIFIE_NON_TRAITE);
            if(!filterNonPlanifieTraite.isSelected()) result.add(NON_PLANIFIE_TRAITE);
            if(!filterPlanifieTraite.isSelected()) result.add(PLANIFIE_TRAITE);
            return result;
        }
    }
}
